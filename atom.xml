<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://juju.run</id>
    <title>不归州</title>
    <updated>2023-07-24T09:53:31.576Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://juju.run"/>
    <link rel="self" href="https://juju.run/atom.xml"/>
    <subtitle>祝冥顽众生，山水有相逢</subtitle>
    <logo>https://juju.run/images/avatar.png</logo>
    <icon>https://juju.run/favicon.ico</icon>
    <rights>All rights reserved 2023, 不归州</rights>
    <entry>
        <title type="html"><![CDATA[ 小诗]]></title>
        <id>https://juju.run/post/xiao-shi/</id>
        <link href="https://juju.run/post/xiao-shi/">
        </link>
        <updated>2023-07-24T03:37:26.000Z</updated>
        <content type="html"><![CDATA[<p>太阳将日子烫出褶皱<br>
影子也开始扭曲<br>
涉遍了上千个世界<br>
没能遇着一场正欢的雪</p>
<p>戴一顶报纸叠的帽子吧<br>
再带上贵重的宝石<br>
影子黏在烤糊的椅子上<br>
给大象照一张很轻的相片<br>
骑在上头，我带它走</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[青春与任性、拖延与幸福]]></title>
        <id>https://juju.run/post/qing-chun-yu-ren-xing-tuo-yan-yu-xing-fu/</id>
        <link href="https://juju.run/post/qing-chun-yu-ren-xing-tuo-yan-yu-xing-fu/">
        </link>
        <updated>2023-07-22T13:54:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="青春与任性">青春与任性</h1>
<h2 id="序章">序章</h2>
<p>我从来不算一个脾气很好的人。开心的时候怎么样都好，不开心的时候就别来撩拨。<br>
18岁高考完，放弃了九江的船舶专业去了潍坊的土木专业，原因只有一个，就是山东比江西离家远。这个扯淡的理由当然说服不了任何人，但是我倔啊，到最后hj被逼无奈，只得说一句：</p>
<blockquote>
<p>“去让撞一次南墙吧，不然他不会死心的。”</p>
</blockquote>
<p>并成功说服了我家老太太。后面她才给我说：</p>
<blockquote>
<p>“我很清楚，你走之后，我们很快就会分手，本来你也没有多爱。”</p>
</blockquote>
<p>当时听过后，其实是无所谓的，因为我们在一起就是巧合，我也不信她有多爱我，所以很快抛之脑后直至断了联系。</p>
<h2 id="初章">初章</h2>
<p>前段时间，jd问了我一句话，我久久无言，她问：</p>
<blockquote>
<p>“你是脑子有病，还是有网恋情节？”</p>
</blockquote>
<p>是的，我和她是网恋认识的，我们都十八岁，她只比我小一个月又三天。作为网友聊天半年后，自然而然地在一起了，甚至谁都没有表白过。又半年，我终于为我当初的任性付出了代价，各种理科科目读不下去，又转不了专业，于是又做了决定：退学。<br>
我暑假退学后，几乎干了所有我能干的工作：电焊、印刷、摆摊、服务员、做小工、发表创作等等，只是那时候心气很高，每行基本都做不了多久，要么嫌累，要么看不到结果，要么一眼就看到结果，所以就常常转行，但也因此也结识了各行各业一些人。<br>
后来有人介绍让我去西安学习编程，正合我胃口，家里待够了，又想出去了。老太太每次都会反驳我的决定，但也每次都拗不过我，于是，我来到西安培训机构求学。<br>
到了西安后很快，我在信用卡借了四千块钱，去了杭州找她，我们正式见了第一面，住在了宾馆。</p>
<h2 id="华章">华章</h2>
<p>来西安后，我住在以脏乱差出名八里村。可是她没嫌弃，时常做十几个小时火车来找我。西安近三年时间，我就去了一次杭州，其他时候，都是她来找我。很快，她就攒了厚厚的一叠车票。<br>
两年半后毕业，因为老太太想让我在西安定居，于是我瞒着家人去了杭州，我们正式同居。<br>
刚到杭州时，我身无分文，她给我找宾馆，我找了一周工作，侥幸入职dw。虽然单位很好，但是众所周知的国情，刚开始工资不是很高，因为要找房子，无奈向家里坦白来杭州的事，要了一些钱，又在城中村定居了。她迁就我，我上班十分钟，她去学校坐公交转车得一个多小时，我们住了一年。这一年，甚至是需要她用生活费补贴家用的一年，也是不敢声张，双方家长打电话过来都要一个人去厕所的一年。<br>
之后我的薪资也慢慢高了起来，我们从城中村搬了出来，她去了我家见了父母，同年我去了她家过年。我们不用像见不得光的地下恋情一样，我们熬过来了。<br>
后来一场突如其来的意外打断了我们平静的生活，她怀孕了。我说，我们生下来吧，去领证。她不愿意，因为她都还没有毕业。我们大吵了一架，她一个人买了车票回家去了。不得已，我只能请假随后去了烟台，放弃了孩子。<br>
到后来这个事情似乎并没有影响到我们。她毕业了，找了工作，而我也升职加薪，事业算是小有成就，于是我们顺理成章的举办了婚礼。只是结婚前她说：</p>
<blockquote>
<p>“结婚后我们要在潍坊买房子定居，离我家近。如果你不愿意的话，我们就分手吧。”</p>
</blockquote>
<p>19年，我放弃了我的事业，我们去了潍坊，我重新白手起家，开始打基本盘。我们也有了孩子，她给取了小名叫“布丁”，我给取了大名叫“秦瑜”，秦安的“秦”，瑾瑜的“瑜”。我想，如果以后我们有了女儿，就起名“安瑾”，秦安的“安”，瑾瑜的“瑾”。<br>
只是之后，不知道为什么，我们吵架和冷战越来越频繁了。</p>
<h2 id="终章">终章</h2>
<p>我以为我可以站在旁观者角度说一些什么，只是，写到这里了，却写不下去了。只是记得她说“离婚”，我说“好”，她说“我不签协议，你去法院起诉吧”，我说“好”。于是在法院，十年的感情被明码标价贩卖，我们，结束了，我和你。</p>
<h1 id="拖延与幸福">拖延与幸福</h1>
<p>我一直有突发奇想及拖延症，且重度。比如说这个网站，一个月前我在朋友圈说脏话被老太太半夜叫起来骂了一顿，就气愤且慷慨激昂的给nx说：</p>
<blockquote>
<p>“我要建站！朋友圈再也不发了！气死我了！”</p>
</blockquote>
<p>结果纠结用hexo还是halo还是用gride搭建，卖服务器动态搭建还是静态托管拖了了好久，拖到昨天才完成。又比如，三月份在成都买了两个密封罐想用来泡酒，一直又没泡，直到今天翻出来，泡了柠檬酒和黄桃酒。<br>
<img src="https://juju.run/post-images/1690040084480.jpg" alt="" loading="lazy"><br>
再比如，因为一周两次停电爬楼梯，当即决定要搬家。第二天找房子，第三天就搬了，顶着大太阳，脸都晒脱皮了。结果后来搬家的司机师傅问我：</p>
<blockquote>
<p>“为啥要搬家？房子不好？还是房东人不行？还是邻居太讨厌？”</p>
</blockquote>
<p>我说没有原因，就是一时激动，就搬了。<br>
为什么这么任性？因为回西安后老太太可能怕刺激到我，一直比较好说话，我给她说我要搬家，她说：</p>
<blockquote>
<p>“想搬就搬呗，没钱我给你”</p>
</blockquote>
<p>突然觉得自己很幸福。脚扭伤却不得不回来的时候，天天电话不断，和nx视频一会儿就得挂掉接一个电话。nx说：</p>
<blockquote>
<p>“你看你多幸福，还整天死啊活啊的乱说，这么多人关心你。”</p>
</blockquote>
<p>确实有点身在福中不知福了。那段时间因为工作和一些原因心情很不好的时候，nx一直陪着说：</p>
<blockquote>
<p>“你别压着火，你朝我发吧，骂我两句，你太压抑了。”</p>
</blockquote>
<p>你看，有人不爱你，但也总有人来爱你的，对吧？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot中的二维码生成]]></title>
        <id>https://juju.run/post/springboot-zhong-de-aes-dui-cheng-jia-jie-mi/</id>
        <link href="https://juju.run/post/springboot-zhong-de-aes-dui-cheng-jia-jie-mi/">
        </link>
        <updated>2023-07-22T02:30:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-pomxml">1. pom.xml</h2>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
        &lt;artifactId&gt;core&lt;/artifactId&gt;
        &lt;version&gt;3.3.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
        &lt;artifactId&gt;javase&lt;/artifactId&gt;
        &lt;version&gt;3.3.3&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<h2 id="2-引入包">2. 引入包</h2>
<pre><code>import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import com.sryc.common.utils.sign.Base64;

import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import java.awt.*;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URL;
import java.util.HashMap;
</code></pre>
<h2 id="3-生成">3. 生成</h2>
<pre><code>public class QRCodeUtils {
    /**
     * 默认宽度
     */
    private static final Integer WIDTH = 350;
    /**
     * 默认高度
     */
    private static final Integer HEIGHT = 350;

    /**
     * LOGO 默认宽度
     */
    private static final Integer LOGO_WIDTH = 50;
    /**
     * LOGO 默认高度
     */
    private static final Integer LOGO_HEIGHT = 50;

    /**
     * 图片格式
     */
    private static final String IMAGE_FORMAT = &quot;png&quot;;
    private static final String CHARSET = &quot;utf-8&quot;;
    /**
     * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析
     */
    private static final String BASE64_IMAGE = &quot;data:image/png;base64,%s&quot;;

    /**
     * 生成二维码，使用默认尺寸
     *
     * @param content 内容
     * @return
     */
    public String getBase64QRCode(String content) {
        return getBase64Image(content, WIDTH, HEIGHT, null, null, null);
    }

    /**
     * 生成二维码，使用默认尺寸二维码，插入默认尺寸logo
     *
     * @param content 内容
     * @param logoUrl logo地址
     * @return
     */
    public String getBase64QRCode(String content, String logoUrl) {
        return getBase64Image(content, WIDTH, HEIGHT, logoUrl, LOGO_WIDTH, LOGO_HEIGHT);
    }

    /**
     * 生成二维码
     *
     * @param content    内容
     * @param width      二维码宽度
     * @param height     二维码高度
     * @param logoUrl    logo 在线地址
     * @param logoWidth  logo 宽度
     * @param logoHeight logo 高度
     * @return
     */
    public String getBase64QRCode(String content, Integer width, Integer height, String logoUrl, Integer logoWidth, Integer logoHeight) {
        return getBase64Image(content, width, height, logoUrl, logoWidth, logoHeight);
    }

    private String getBase64Image(String content, Integer width, Integer height, String logoUrl, Integer logoWidth, Integer logoHeight) {
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        BufferedImage bufferedImage = crateQRCode(content, width, height, logoUrl, logoWidth, logoHeight);
        try {
            ImageIO.write(bufferedImage, IMAGE_FORMAT, os);
        } catch (IOException e) {
            System.out.println(&quot;[生成二维码，错误&quot;+e+&quot;]&quot;);
        }
        // 转出即可直接使用
        return String.format(BASE64_IMAGE, Base64.encode(os.toByteArray()));
    }


    /**
     * 生成二维码
     *
     * @param content    内容
     * @param width      二维码宽度
     * @param height     二维码高度
     * @param logoUrl    logo 在线地址
     * @param logoWidth  logo 宽度
     * @param logoHeight logo 高度
     * @return
     */
    private BufferedImage crateQRCode(String content, Integer width, Integer height, String logoUrl, Integer logoWidth, Integer logoHeight) {
        if (StringUtils.isNotBlank(content)) {
            ServletOutputStream stream = null;
            HashMap&lt;EncodeHintType, Comparable&gt; hints = new HashMap&lt;&gt;(4);
            // 指定字符编码为utf-8
            hints.put(EncodeHintType.CHARACTER_SET, CHARSET);
            // 指定二维码的纠错等级为中级
            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);
            // 设置图片的边距
            hints.put(EncodeHintType.MARGIN, 2);
            try {
                QRCodeWriter writer = new QRCodeWriter();
                BitMatrix bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, width, height, hints);
                BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
                for (int x = 0; x &lt; width; x++) {
                    for (int y = 0; y &lt; height; y++) {
                        bufferedImage.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF);
                    }
                }
                if (StringUtils.isNotBlank(logoUrl)) {
                    insertLogo(bufferedImage, width, height, logoUrl, logoWidth, logoHeight);
                }
                return bufferedImage;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (stream != null) {
                    try {
                        stream.flush();
                        stream.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        return null;
    }

    /**
     * 二维码插入logo
     *
     * @param source     二维码
     * @param width      二维码宽度
     * @param height     二维码高度
     * @param logoUrl    logo 在线地址
     * @param logoWidth  logo 宽度
     * @param logoHeight logo 高度
     * @throws Exception
     */
    private void insertLogo(BufferedImage source, Integer width, Integer height, String logoUrl, Integer logoWidth, Integer logoHeight) throws Exception {
        // logo 源可为 File/InputStream/URL
        Image src = ImageIO.read(new URL(logoUrl));
        // 插入LOGO
        Graphics2D graph = source.createGraphics();
        int x = (width - logoWidth) / 2;
        int y = (height - logoHeight) / 2;
        graph.drawImage(src, x, y, logoWidth, logoHeight, null);
        Shape shape = new RoundRectangle2D.Float(x, y, logoWidth, logoHeight, 6, 6);
        graph.setStroke(new BasicStroke(3f));
        graph.draw(shape);
        graph.dispose();
    }


    /**
     * 获取二维码
     *
     * @param content 内容
     * @param output  输出流
     * @throws IOException
     */
    public void getQRCode(String content, OutputStream output) throws IOException {
        BufferedImage image = crateQRCode(content, WIDTH, HEIGHT, null, null, null);
        ImageIO.write(image, IMAGE_FORMAT, output);
    }

    /**
     * 获取二维码
     *
     * @param content 内容
     * @param logoUrl logo资源
     * @param output  输出流
     * @throws Exception
     */
    public void getQRCode(String content, String logoUrl, OutputStream output) throws Exception {
        BufferedImage image = crateQRCode(content, WIDTH, HEIGHT, logoUrl, LOGO_WIDTH, LOGO_HEIGHT);
        ImageIO.write(image, IMAGE_FORMAT, output);
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot中的RSA非对称加解密]]></title>
        <id>https://juju.run/post/springboot-rsa/</id>
        <link href="https://juju.run/post/springboot-rsa/">
        </link>
        <updated>2023-07-22T02:13:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-pomxml">1. pom.xml</h2>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
    &lt;/dependency&gt; 
</code></pre>
<h2 id="2-引入包">2. 引入包</h2>
<pre><code>import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;
import java.util.*;
</code></pre>
<h2 id="3-加解密">3. 加解密</h2>
<pre><code>public class RsaUtils {

    /**
     * RSA最大加密明文大小
     */
    private static final int MAX_ENCRYPT_BLOCK = 117;

    /**
     * RSA最大解密密文大小
     */
    private static final int MAX_DECRYPT_BLOCK = 128;

    /**
     * 获取密钥对
     *
     * @return 密钥对
     */
    public static KeyPair getKeyPair() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(&quot;RSA&quot;);
        generator.initialize(1024);
        return generator.generateKeyPair();
    }

    /**
     * 获取私钥
     *
     * @param privateKey 私钥字符串
     * @return
     */
    public static PrivateKey getPrivateKey(String privateKey) throws Exception {
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        byte[] decodedKey = com.sun.org.apache.xerces.internal.impl.dv.util.Base64.decode(new String(privateKey.getBytes()));
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decodedKey);
        return keyFactory.generatePrivate(keySpec);
    }

    /**
     * 获取公钥
     *
     * @param publicKey 公钥字符串
     * @return
     */
    public static PublicKey getPublicKey(String publicKey) throws Exception {
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        byte[] decodedKey = Base64.getDecoder().decode(publicKey);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(decodedKey);
        return keyFactory.generatePublic(keySpec);
    }

    /**
     * RSA加密
     *
     * @param data      待加密数据
     * @param publicKey 公钥
     * @return
     */
    public static String encrypt(String data, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        int inputLen = data.getBytes().length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offset = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offset &gt; 0) {
            if (inputLen - offset &gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data.getBytes(), offset, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data.getBytes(), offset, inputLen - offset);
            }
            out.write(cache, 0, cache.length);
            i++;
            offset = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        // 获取加密内容使用base64进行编码,并以UTF-8为标准转化成字符串
        // 加密后的字符串
        return new String(Base64.getEncoder().encode((encryptedData)));
    }

    /**
     * RSA解密
     *
     * @param data       待解密数据
     * @param privateKey 私钥
     * @return
     */
    public static String decrypt(String data, PrivateKey privateKey) throws Exception {

        Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] dataBytes = Base64.getDecoder().decode(data);
        int inputLen = dataBytes.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offset = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offset &gt; 0) {
            if (inputLen - offset &gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(dataBytes, offset, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(dataBytes, offset, inputLen - offset);
            }
            out.write(cache, 0, cache.length);
            i++;
            offset = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        // 解密后的内容
        return new String(decryptedData, &quot;UTF-8&quot;);
    }

    /**
     * 对数据签名
     *
     * @param data       待签名数据
     * @param privateKey 私钥
     * @return 签名
     */
    public static String sign(String data, PrivateKey privateKey) throws Exception {
        byte[] keyBytes = privateKey.getEncoded();
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        PrivateKey key = keyFactory.generatePrivate(keySpec);
        Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);
        signature.initSign(key);
        signature.update(data.getBytes());
        return Base64.getEncoder().encodeToString(signature.sign());
    }

    /**
     * 验签
     *
     * @param srcData   原始字符串
     * @param publicKey 公钥
     * @param sign      签名
     * @return 是否验签通过
     */
    public static boolean verify(String srcData, PublicKey publicKey, String sign) throws Exception {
        byte[] keyBytes = publicKey.getEncoded();
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        PublicKey key = keyFactory.generatePublic(keySpec);
        Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);
        signature.initVerify(key);
        signature.update(srcData.getBytes());
        return signature.verify(Base64.getDecoder().decode(sign));
    }

    /**
     * main测试
     * @param args
     */
    public static void main(String[] args) {
        try {
            // 生成密钥对
            KeyPair keyPair = getKeyPair();
            String privateKey = new String(Base64.getEncoder().encode(keyPair.getPrivate().getEncoded()));
            String publicKey = new String(Base64.getEncoder().encode(keyPair.getPublic().getEncoded()));

            System.out.println(&quot;私钥:&quot; + privateKey);
            System.out.println(&quot;公钥:&quot; + publicKey);

            // RSA加密
            String data = &quot;111&quot;;
            String encryptData = encrypt(data, getPublicKey(publicKey));
            System.out.println(&quot;加密后内容:&quot; + encryptData);
            // RSA解密
            String decryptData = decrypt(encryptData, getPrivateKey(privateKey));
            System.out.println(&quot;解密后内容:&quot; + decryptData);

            // RSA签名
            String sign = sign(data, getPrivateKey(privateKey));
            System.out.print(&quot;RSA签名:&quot; + sign);
            // RSA验签
            boolean result = verify(data, getPublicKey(publicKey), sign);
            System.out.print(&quot;验签结果:&quot; + result);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.print(&quot;加解密异常&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无题]]></title>
        <id>https://juju.run/post/wu-ti/</id>
        <link href="https://juju.run/post/wu-ti/">
        </link>
        <updated>2023-07-21T14:10:28.000Z</updated>
        <content type="html"><![CDATA[<p>月亮一病不起，寂寂低垂<br>
照在你身上，哪一寸是我？<br>
你将船径直的开过去<br>
河底的沉尸至今下落不明</p>
<p>船行过凌乱的碎片与剪影<br>
你弯腰捡拾，剥茧抽丝<br>
未能凑出一件像样的心事<br>
一直想听一个答案，一直问你<br>
你没回答，反复迟疑<br>
从此爱意闭口不提</p>
<p>于是我躺在粼粼流淌的河水中<br>
大睡一场，梦到那个<br>
愿意为我投河而死的人<br>
在悬而未决的人间风月里<br>
送给我一轮完美的皎洁</p>
]]></content>
    </entry>
</feed>